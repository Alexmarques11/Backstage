

 






Mestrado em Engenharia Informática

Arquitetura e Integração de Sistemas
Backstage

Grupo 6:
               a25968 – Alexandre Marques
a25965 – Gonçalo Moreira
             a25979 – José Oliveira













14 de novembro de 2025
Índice
1.	Introdução	5
1.1	Problema Identificado	5
1.2	Solução Proposta	5
1.2.1	Hub Centralizado de informação sobre Concertos/Eventos	5
1.2.2	Marketplace para Revenda de Bilhetes	6
1.2.3	Plataforma de Promoção de Artistas	6
1.2.4	Passaporte de Concertos	6
1.3	Experiência do Utilizador	7
1.4	Público-Alvo	8
2.	Implementação Técnica	10
2.1	Ferramentas	10
2.1.1	Kotlin + Jetpack Compose - Frontend mobile	10
2.1.2	Node.js - Backend/Microsserviços	10
2.1.3	Postgres - Base de Dados	10
2.1.4	Docker - Conteinerização	11
2.1.5	DigitalOcean - Cluster kubernetes	11
2.1.6	Github Actions - CI/CD	11
2.1.7	NGINX - API Gateway	11
2.1.8	Figma - Prototipagem UI/UX	12
2.2	 Estrutura de Dados	12
2.3	Microsserviços	13
2.3.1	Serviço de Autenticação e Gestão de Utilizadores	13
2.3.2	Sistema de publicações de concertos	14
2.3.3	Serviço de Eventos e Concertos	15
2.3.4	Market Place de bilhetes	15
2.3.5	Passaporte de Concertos	16
2.3.6	Notificações	17
2.4	 Arquitetura Global do Sistema	18
2.5	BPMN Genérico da Aplicação	19
3.	Desenvolvimento Técnico	20
3.1	Microsserviços	20
3.1.1	Autenticação de Gestão de Utilizadore	20
3.1.2	Publicações de Concertos	20
3.1.3	Eventos – Ticketmaster	20
3.1.4	Marketplace	20
3.1.5	Passaporte	20
3.1.6	Notificações	20
3.2	Segurança entre Microsserviços	20
3.3	Comunicação entre Microsserviços	20
3.3.1	Comunicação Síncrona	20
3.3.2	Comunicação Assíncrona	20
3.4	Publicação em Cloud	20
3.4.1	Containerização e Kubernetes	20
3.4.2	Escalabilidade	20
3.5	Instalação e Configuração	20
4.	Conclusão	21
4.1	Objetivos Atingidos	21
4.2	Problemas Encontrados	21
4.3	Melhorias Futuras	21


 
Índice de Figuras
Figura 1 - Modelo Base de Dados	11
Figura 2- Diagrama da Arquitetura da Aplicação	17

 
1.	Introdução

1.1	 Problema Identificado
No panorama atual, os entusiastas da música enfrentam múltiplos desafios que dificultam a sua experiência com concertos e eventos ao vivo:
•	Dispersão de Informação: A ausência de uma plataforma centralizada obriga os fãs a pesquisar em diversas fontes para obter detalhes cruciais sobre concertos, como datas, horários, locais, preços de bilhetes e métodos de aquisição. Esta fragmentação torna a descoberta de eventos de grandes artistas uma tarefa demorada.
•	Dificuldade na Revenda de Bilhetes: Utilizadores que adquirem bilhetes e, por imprevistos, não podem comparecer ao evento, encontram obstáculos significativos na revenda segura e eficiente dos mesmos. As soluções existentes, como as redes sociais, limitam o alcance a um círculo restrito de contactos, dificultando a concretização da venda e aumentando o risco de fraude.
•	Visibilidade para Artistas Emergentes: Artistas independentes e de pequena dimensão lutam para promover os seus concertos e alcançar um público mais vasto, perdendo oportunidades de crescimento e conexão com novos fãs.
1.2	 Solução Proposta
A Backstage surge como uma resposta inovadora a estes desafios, oferecendo uma plataforma multifacetada que enriquece a jornada do fã de música e impulsiona a cena musical:
1.2.1	Hub Centralizado de informação sobre Concertos/Eventos
Um feed dinâmico e personalizável agregará informações detalhadas sobre concertos de artistas de todos os portes. Os utilizadores terão acesso fácil a dados como:
o	Detalhes do Evento: Data, hora, local, artistas confirmados.
o	Informação de Bilheteira: Preço, categorias de bilhetes, capacidade do recinto e links diretos para plataformas de compra oficiais.
o	Alertas Personalizados: Notificações sobre os seus artistas ou géneros musicais favoritos e de concertos perto do utilizador.
1.2.2	Marketplace para Revenda de Bilhetes
Iremos desenvolver um ambiente para os utilizadores venderem / comprarem bilhetes de outros utilizadores.
o	Funcionalidade Principal: Os utilizadores terão a capacidade de criar os seus próprios anúncios de venda de bilhetes. Estes anúncios permitirão incluir toda a informação relevante sobre o bilhete, os detalhes de como o vendedor pretende efetuar a transação e os dados de contacto do vendedor (e-mail, contacto telefónico, etc.). Importante: é fundamental esclarecer que a aplicação não irá gerir diretamente a compra ou venda dos bilhetes. O nosso papel limita-se exclusivamente à criação e gestão dos anúncios dentro do Marketplace, funcionando como um ponto de encontro para os utilizadores.
1.2.3	Plataforma de Promoção de Artistas
Além de grandes nomes, a aplicação dedicará espaço para artistas independentes e de pequena dimensão, ou até mesmo organizadores de eventos possam divulgar os seus concertos/eventos, tentando alcançar um novo público e construir a sua base de fãs.
o	Publicações de Eventos: Os utilizadores poderão criar anúncios detalhados para os seus concertos ou eventos. Estas publicações incluirão informações essenciais como localização, preço, géneros musicais e outros dados relevantes.
o	Notificações Personalizadas: Com base na informação fornecida, a aplicação enviará notificações personalizadas aos utilizadores casuais. Estas notificações alertarão sobre concertos/eventos que correspondam aos seus gostos musicais ou que ocorram na sua proximidade.
o	Benefícios: Maior visibilidade, acesso a ferramentas de promoção direcionadas e a possibilidade de se conectarem com entusiastas da música que procuram novas descobertas.
1.2.4	Passaporte de Concertos
Esta é uma funcionalidade exclusiva que permite aos utilizadores registar, organizar e partilhar as suas experiências em cada concerto, transformando cada evento numa memória digital.
o	Como funciona: O utilizador pode criar publicações sobre os concertos a que assistiu, adicionando fotos, vídeos, notas pessoais e avaliações.
o	Valor Adicionado: 
	Estatísticas Personalizadas: A plataforma gera automaticamente estatísticas interessantes baseadas no histórico do utilizador, tais como: o número total de concertos assistidos, os artistas mais vistos, os géneros musicais preferidos e os locais mais frequentados.
	Narrativa Visual e Pessoal: O histórico musical do utilizador é transformado numa narrativa envolvente, permitindo reviver momentos e acompanhar a sua jornada musical.
	Mapa Interativo de Concertos: Todos estes dados são apresentados num mapa interativo, que destaca visualmente todos os locais onde o utilizador já assistiu a concertos, oferecendo uma perspetiva geográfica das suas aventuras musicais.
1.3	 Experiência do Utilizador
Com a Backstage, a jornada dos entusiastas da música e dos organizadores de eventos é significativamente otimizada e enriquecida. A aplicação foi desenhada para ser intuitiva e poderosa, transformando os desafios atuais em experiências fluidas e personalizadas:
Para o Fã de Música (Utilizador Comum):
•	Descoberta Centralizada e Eficiente:
o	O utilizador acede a um feed único e personalizável onde encontra facilmente informações detalhadas sobre todos os concertos de seu interesse, eliminando a necessidade de pesquisar em múltiplas fontes. A app apresenta dados como datas, horários, locais, artistas, géneros e links diretos para compra de bilhetes oficiais.
•	Alertas e Recomendações Personalizadas:
o	Pode adicionar facilmente os seus géneros favoritos e receber notificações sobre novos concertos que correspondam aos seus gostos ou que aconteçam perto da sua localização. Isto garante que nunca mais perde um evento imperdível.
•	Gestão de Bilhetes para Revenda Simplificada:
o	Caso não possa comparecer a um concerto, o utilizador pode criar um anúncio de revenda de bilhetes de forma rápida e segura na plataforma. A app oferece visibilidade a um vasto público interessado, facilitando a comunicação com potenciais compradores e a gestão do seu anúncio.
•	Memórias e Estatísticas Personalizadas com o "Passaporte de Concertos":
o	Após cada concerto, o utilizador pode registar a sua experiência através de posts com fotos, vídeos e notas. O "Passaporte de Concertos" gera automaticamente estatísticas visuais e mapas interativos dos eventos a que assistiu, transformando o seu histórico musical numa narrativa pessoal e divertida.
Para Artistas e Organizadores de Concertos/Eventos:
•	Promoção Direcionada e Maior Alcance:
o	Artistas e organizadores têm acesso a uma plataforma dedicada para divulgar os seus eventos a um público já interessado em música. Podem alcançar não só os seus fãs existentes, mas também novos entusiastas que procuram descobertas, aumentando a visibilidade e o potencial de vendas.

1.4	 Público-Alvo

A Backstage foi concebida para ser o ponto de encontro de todos os que vivem e respiram música ao vivo. O nosso público-alvo é diversificado, abrangendo desde o fã mais devoto até ao artista que procura a sua voz, e o promotor que sonha em encher as salas.
•	Para o Fã Apaixonado (e o Curioso!): Seja o "caçador de concertos" que segue os seus artistas preferidos por todo o país, o entusiasta que adora descobrir novos talentos e géneros, ou o fã casual que simplesmente procura uma boa noite de música na sua área. Oferecemos uma experiência completa para quem quer estar a par dos eventos, gerir os seus bilhetes com facilidade e preservar as memórias inesquecíveis de cada espetáculo.
•	Para Artistas e Bandas Emergentes: Reconhecemos o desafio de ganhar visibilidade num mercado competitivo. Se é um músico independente, parte de uma banda a tentar fazer-se ouvir, ou um criador de eventos que anseia por um palco maior, a nossa plataforma é o seu aliado. Oferecemos as ferramentas para que os seus espetáculos cheguem aos ouvidos certos, ajudem a construir a sua base de fãs e transformem os seus sonhos em realidade.
•	Para Promotores e Organizadores de Eventos: Desde os pequenos eventos locais aos festivais, sabemos que a divulgação eficaz é chave para o sucesso. A app proporciona uma ferramenta poderosa e direcionada para alcançar um público interessado, otimizando a promoção e garantindo que cada evento encontra a sua audiência ideal.

 
2.	Implementação Técnica

2.1	 Ferramentas 
Para o desenvolvimento e implementação da aplicação Backstage, foi selecionado um conjunto de ferramentas que asseguram a criação de uma solução moderna, escalável e alinhada com os princípios cloud-native. Estas ferramentas abrangem todo o ciclo de vida da aplicação, desde o design inicial da interface até ao desenvolvimento do frontend e backend, passando pela gestão de dados, conteinerização, orquestração em Kubernetes, integração contínua e monitorização do sistema em produção. A escolha de cada tecnologia teve como critério a robustez, a maturidade da comunidade de suporte e a sua capacidade de integração com o ecossistema cloud, garantindo assim uma base sólida para o sucesso do projeto.
2.1.1	Kotlin + Jetpack Compose - Frontend mobile
Para o desenvolvimento do frontend móvel, optou-se pela utilização de Kotlin em conjunto com o Jetpack Compose, a framework declarativa da Google para criação de interfaces modernas e reativas em Android. Esta abordagem permite desenvolver uma aplicação com desempenho nativo, UI responsiva e elevada capacidade de personalização, aproveitando ao máximo os recursos do sistema operativo.
2.1.2	Node.js - Backend/Microsserviços
O Node.js foi escolhido como tecnologia base para o desenvolvimento dos microsserviços da aplicação. A sua natureza assíncrona e orientada a eventos permite lidar eficientemente com um grande volume de pedidos, característica essencial para uma aplicação cloud-native. Além disso, a vasta comunidade e o ecossistema de pacotes disponíveis através do npm tornam o Node.js uma solução prática, escalável e de fácil integração com outras ferramentas.
2.1.3	Postgres - Base de Dados
O PostgreSQL foi escolhido como sistema de gestão de base de dados relacional para a aplicação. Esta escolha deve-se à sua robustez, escalabilidade e suporte avançado a queries complexas, o que permite gerir de forma eficiente a informação estruturada da aplicação. Além disso, o PostgreSQL oferece compatibilidade com diversos frameworks de desenvolvimento e integra-se facilmente em ambientes cloud-native, garantindo consistência e fiabilidade na persistência dos dados.
2.1.4	Docker - Conteinerização
O Docker é utilizado para criar, distribuir e executar os microsserviços em ambientes isolados através de contentores. Esta abordagem garante consistência entre ambientes de desenvolvimento, teste e produção, evitando problemas de compatibilidade. Com o Docker, a aplicação torna-se mais portátil e facilmente escalável, sendo ainda um requisito essencial para a sua integração com o Kubernetes.
2.1.5	DigitalOcean - Cluster kubernetes
Para efeitos de desenvolvimento e produção, será utilizado o DigitalOcean como solução para criar e gerir um cluster Kubernetes. Esta plataforma fornece um ambiente Kubernetes totalmente gerido, permitindo o deployment, escalabilidade e monitorização dos microsserviços de forma simplificada e confiável. A escolha do DigitalOcean possibilita a implementação prática de conceitos de orquestração, gestão de pods e configuração de serviços em um ambiente cloud real, garantindo maior robustez e preparação para o escalonamento da aplicação em produção.
2.1.6	Github Actions - CI/CD
O GitHub Actions será utilizado para a implementação de pipelines de integração contínua (CI) e entrega contínua (CD). Esta ferramenta permite automatizar processos críticos como execução de testes, validação de código com linters, construção de imagens Docker e deployment no cluster Kubernetes. Desta forma, garante-se maior fiabilidade no processo de desenvolvimento e entrega, promovendo práticas DevOps modernas e alinhadas com o paradigma cloud-native.
2.1.7	NGINX - API Gateway
O NGINX será utilizado como API Gateway, responsável por gerir e rotear as requisições entre os diferentes microsserviços. Além de simplificar o acesso externo à aplicação, o NGINX oferece funcionalidades avançadas como balanceamento de carga compressão e segurança. Esta camada central assegura uma comunicação eficiente e controlada, melhorando o desempenho global do sistema e permitindo uma gestão mais clara das APIs disponibilizadas.
2.1.8	Figma - Prototipagem UI/UX
O Figma será utilizado como ferramenta de design colaborativo para a criação de protótipos da interface da aplicação. Esta escolha permite uma prototipagem rápida e partilha em tempo real com os membros da equipa, garantindo uma experiência de utilizador intuitiva e consistente. A utilização do Figma possibilita validar antecipadamente conceitos de design, reduzindo erros e retrabalho na fase de desenvolvimento.
2.2	 Estrutura de Dados


A presente secção apresenta a base de dados da aplicação Backstage, responsável por armazenar e gerir a informação essencial ao funcionamento da plataforma.
A base de dados foi implementada em PostgreSQL, um sistema de gestão de bases de dados relacional que oferece robustez, escalabilidade e suporte a operações complexas de consulta e relacionamento entre entidades.
O modelo de dados foi concebido para refletir as principais funcionalidades da aplicação, garantindo a organização lógica e consistente da informação dos utilizadores, concertos, eventos, localizações, publicações e interações.
Através da definição de relações entre tabelas e da utilização de chaves primárias e estrangeiras, assegura-se a integridade e coerência dos dados ao longo de toda a aplicação.
Esta estrutura constitui um componente central da arquitetura da Backstage, servindo como base para o armazenamento persistente e a integração entre os diferentes módulos e microsserviços da plataforma.
2.3	 Microsserviços
A arquitetura de microsserviços constitui a base da estrutura backend da aplicação Backstage, permitindo que o sistema seja desenvolvido de forma modular, escalável e facilmente mantido ao longo do tempo. Cada microsserviço será responsável por um conjunto específico de funcionalidades da aplicação, operando de forma independente, mas comunicando entre si através de APIs bem definidas.
Esta abordagem possibilita que cada componente da plataforma, como gestão de utilizadores, concertos, marketplace, notificações ou passaporte de concertos, seja desenvolvido, testado, implementado e escalado de forma isolada, sem impactar diretamente os restantes módulos. Assim, garante-se uma maior flexibilidade no desenvolvimento e uma capacidade mais eficiente de adaptação a futuras evoluções do projeto.
Durante a fase inicial, será implementada uma estrutura base que contempla a criação e integração dos principais microsserviços, bem como o estabelecimento das rotas de comunicação entre eles. A orquestração será assegurada através do Kubernetes, enquanto o NGINX atuará como API Gateway, centralizando o acesso e o encaminhamento das requisições externas.
2.3.1	Serviço de Autenticação e Gestão de Utilizadores
Este serviço é responsável por todo o ciclo de vida dos utilizadores na aplicação, incluindo o processo de registo, autenticação e manutenção das informações de perfil. Este microserviço gerirá dados como nome, apelido, e-mail, username, idade, avatar e preferências musicais, garantindo que cada utilizador tenha uma experiência personalizada e segura. Além disso, disponibilizará endpoints para operações como criação e atualização de perfis, definição de preferências e gestão de tokens de sessão, assegurando uma comunicação segura entre o frontend e o backend através de mecanismos de autenticação baseados em tokens (como JWT).
•	Endpoints:
o	POST   /auth/register - Regista um novo utilizador na plataforma.
o	POST   /auth/login - Autêntica o utilizador e gera um token de sessão.
o	POST   /auth/logout - Invalida o token atual, terminando a sessão do utilizador.
o	POST   /auth/refresh-token - Gera um novo token a partir de um token de refresh válido.
o	GET    /users/profile - Obtém os dados do perfil do utilizador autenticado.
o	PUT    /users/profile - Atualiza as informações do perfil do utilizador.
o	PUT    /users/preferences - Atualiza as preferências musicais ou de utilização.
o	GET    /users/preferences - Devolve as preferências musicais do utilizador.
o	POST   /users/upload-avatar - Permite enviar e atualizar a imagem de avatar do utilizador.

2.3.2	Sistema de publicações de concertos
Este sistema permitirá que qualquer utilizador da plataforma crie, edite ou elimine publicações relacionadas com concertos e eventos. Cada publicação incluirá informações essenciais, como título, descrição, artista ou banda, data, local, género musical e imagem de capa. Este microsserviço será fundamental para a promoção de eventos tanto por artistas como por fãs, funcionando como uma vitrine colaborativa e atualizada em tempo real. Além disso, disponibilizará endpoints para consulta e filtragem de publicações, seja por ID, por utilizador ou por parâmetros de pesquisa.
•	Endpoints:

o	POST /publications/posts - Cria uma nova publicação do tipo concerto.
o	GET /publications/posts - Lista todas as publicações disponíveis.
o	GET /publications/posts/{publicationId} - Obtém detalhes de uma publicação específica.
o	PUT /publications/posts/{publicationId} - Edita uma publicação existente.
o	DELETE /publications/posts/{publicationId} - Remove uma publicação do sistema.
o	GET /users/{userId}/publications - Lista todas as publicações criadas por um determinado utilizador.
2.3.3	Serviço de Eventos e Concertos
O Serviço de Eventos e Concertos será responsável por recolher e tratar informações sobre concertos e eventos futuros através da integração com APIs externas especializadas. O seu principal objetivo é obter dados atualizados sobre eventos musicais, incluindo nome do artista, data, local, preços, links oficiais e outros detalhes relevantes e processá-los de forma a uniformizar a informação antes da sua utilização interna. Após a recolha e normalização desses dados, o serviço disponibilizará as informações necessárias para a criação automática. Desta forma, este microsserviço funcionará como uma ponte entre fontes externas de dados e o ecossistema interno da Backstage, garantindo que as publicações de eventos sejam consistentes, completas e sempre baseadas em informação real e atualizada.
•	Endpoints:
o	GET    /concerts/{concertsId} - Obtém detalhes normalizados de um concerto proveniente de APIs externas.
o	GET    /concerts?title=X&location=Y - Pesquisa concertos filtrando por artista e localização.
o	GET    /concerts - Lista os concertos disponíveis após agregação das APIs externas.
o	GET    /concerts/{concertId} - Obtém dados detalhados de um concerto específico.
o	GET    /concerts/search - Permite pesquisar concertos por termos genéricos (artista, local, nome, etc.).
o	GET    /concerts/by-artist/{artistId} - Obtém concertos relacionados com um artista específico.
o	GET    /concerts/location - Lista concertos filtrados por localização. 	
o	GET    /concerts/by-genre/{genre} - Lista concertos filtrados por género musical.

2.3.4	Market Place de bilhetes
O marketplace permitirá aos utilizadores criar e gerir anúncios de venda de bilhetes, oferecendo um espaço seguro e transparente para interações entre fãs. Inspirado em plataformas como o OLX, este microsserviço possibilitará a criação, edição e eliminação de anúncios, armazenando informações detalhadas como título, descrição, imagens e dados do vendedor. Importa referir que a aplicação não intermediará transações financeiras, funcionando apenas como ponto de encontro entre compradores e vendedores. Este microsserviço incluirá ainda mecanismos de pesquisa e filtragem de anúncios, bem como endpoints para listar bilhetes por utilizador ou estado, promovendo uma experiência organizada e intuitiva para os utilizadores.
•	Endpoints:
o	POST   /marketplace/listings - Cria um novo anúncio de venda de bilhetes.
o	GET    /marketplace/listings - Lista todos os anúncios publicados.
o	GET   /marketplace/listings/{listingId} - Obtém informações detalhadas de um anúncio.
o	PUT    /marketplace/listings/{listingId} - Atualiza os dados de um anúncio existente.
o	DELETE /marketplace/listings/{listingId} - Remove um anúncio da plataforma.
o	GET    /marketplace/listings/user/{userId} - Lista os anúncios criados por um utilizador.
o	GET   /marketplace/marketplace/listings?query - Permite pesquisar ou filtrar anúncios
o	PUT    /marketplace/listings/{listingId}/status - Altera o estado do anúncio

2.3.5	Passaporte de Concertos
O Passaporte de Concertos oferecerá aos utilizadores uma forma personalizada de registar e recordar as suas experiências em eventos musicais. Este microsserviço permitirá criar publicações associadas aos concertos frequentados, incluindo avaliações, comentários, fotografias e localizações. As informações armazenadas serão utilizadas para gerar estatísticas personalizadas, como artistas mais vistos, locais mais visitados e géneros predominantes, e apresentadas através de visualizações interativas, como mapas e gráficos. Para a componente geográfica, será integrada a API externa do Google Maps, que permitirá representar visualmente os locais onde o utilizador já assistiu a concertos, criando um mapa interativo e dinâmico. Endpoints:
o	POST   /passport/posts - Cria uma publicação no passaporte.
o	GET    /passport/posts - Lista todas as publicações do passaporte do utilizador.
o	GET    /passport/posts/{postId} - Obtém detalhes de uma publicação específica.
o	PUT    /passport/posts/{postId} - Atualiza uma publicação já existente.
o	DELETE /passport/posts/{postId} -Remove uma publicação do passaporte.
o	GET    /passport/statistics - Gera estatísticas personalizadas sobre a atividade musical do utilizador.
o	GET    /passport/map - Devolve os dados geográficos para gerar o mapa via Google Maps API.
	
2.3.6	Notificações
O Serviço de Notificações será responsável por gerir a comunicação entre a plataforma e os utilizadores, assegurando que estes são informados sobre eventos relevantes, novos concertos, etc. Este microsserviço disponibilizará endpoints para consulta, marcação de notificações como lidas, gestão de preferências e subscrição de alertas personalizados. Para o envio de notificações em tempo real, será integrada uma API externa especializada em push notifications, garantindo que os utilizadores recebam alertas imediatos e confiáveis, independentemente do seu dispositivo ou localização. 
•	Endpoints:
o	GET    /notifications - Lista todas as notificações do utilizador.
o	POST   /notifications/mark-read/{notificationId} - Marca uma notificação como lida.
o	PUT    /notifications/settings - Atualiza as preferências de notificações do utilizador.
o	POST   /notifications/subscriptions - Subscreve o utilizador para receber notificações.
o	DELETE /notifications/subscriptions/{id} - Cancela uma “subscrição” de notificações.



2.4	 Arquitetura Global do Sistema

A arquitetura da Backstage segue um padrão de microsserviços cloud-native, estruturada em camadas bem definidas que garantem escalabilidade, modularidade e facilidade de manutenção. No topo da arquitetura, encontra-se o frontend desenvolvido em Kotlin, que comunica através de um API Gateway baseado em NGINX responsável pelo roteamento inteligente e balanceamento de carga entre os diferentes microsserviços. A camada de microsserviços é composta por seis serviços especializados: o Serviço de Autenticação, o Sistema de Publicações para criação de concertos, o Marketplace de Bilhetes para revenda entre utilizadores, o Passaporte de Concertos para memórias pessoais, o serviço de Eventos que integra APIs externas, e o sistema de Notificações para alertas personalizados. A arquitetura da Backstage adota uma base de dados relacional para cada microsserviço, em PostgreSQL. Esta decisão visa a modularidade e escalabilidade dos microserviços, permanecendo a consistência e reduzindo a dificuldade de adicionar futuros micro serviços.
As bases de dados armazenam todas as informações essenciais, incluindo dados de utilizadores, eventos, publicações, vendas de bilhetes e passaportes. Estas são acedidas por cada microsserviço através de interfaces bem definidas e controladas. A arquitetura integra serviços externos como APIs de eventos e push notifications.



2.5	 BPMN Genérico da Aplicação
 
3.	Desenvolvimento Técnico

3.1	 Microsserviços 

A arquitetura de microsserviços da Backstage foi implementada seguindo princípios de desacoplamento, autonomia e responsabilidade única. Cada microsserviço opera de forma independente, com a sua própria base de dados PostgreSQL, garantindo isolamento de dados e facilitando a manutenção e escalabilidade individual de cada componente.

3.1.1	Autenticação e Gestão de Utilizadores

O serviço de autenticação foi desenvolvido em Node.js/Express e constitui a base de segurança da aplicação. Implementa um sistema completo de gestão de identidade, incluindo:

•	Sistema de Registo e Login: Permite aos utilizadores criarem contas com validação de dados (email, password strength, campos obrigatórios). As passwords são encriptadas utilizando bcrypt antes de serem armazenadas na base de dados.

•	Autenticação baseada em JWT: Após login bem-sucedido, o serviço gera dois tokens:
o	Access Token: Token de curta duração (15-30 minutos) utilizado para autenticar pedidos à API.
o	Refresh Token: Token de longa duração armazenado de forma segura que permite renovar o access token sem obrigar o utilizador a fazer login novamente.

•	Gestão de Perfis: Os utilizadores podem atualizar informações pessoais (nome, apelido, data de nascimento) e definir preferências musicais (géneros favoritos) que serão utilizadas pelo sistema de recomendações.

•	Middleware de Autenticação: Fornece middleware reutilizável (authenticateToken) que outros microsserviços podem utilizar para validar tokens JWT e proteger endpoints.

•	Sistema de Seguir/Deixar de Seguir: Implementa relações sociais entre utilizadores, permitindo que os fãs sigam outros utilizadores e vejam as suas atividades.

•	Integração com RabbitMQ: Publica eventos quando novos utilizadores são criados, permitindo que outros serviços (como notificações) reajam a estas ações.

A base de dados auth_db armazena informações de utilizadores, tokens de refresh, relações de seguimento e preferências musicais.

•	Endpoints API:
	Autenticação:
o	POST /auth/register - Registo de novos utilizadores com validação de dados e encriptação de password.
o	POST /auth/login - Autenticação de utilizador, gerando access token e refresh token.
o	POST /auth/logout - Invalidação de tokens, terminando a sessão do utilizador.
o	POST /auth/refresh-token - Renovação de access token usando refresh token válido.

	Gestão de Perfil:
o	GET /user/profile/:id - Obtém dados completos do perfil de um utilizador.
o	PUT /user/profile/:id - Atualiza informações pessoais (nome, apelido, email, etc.).
o	DELETE /user/profile/:id - Elimina conta do utilizador (requer autenticação).

	Preferências Musicais:
o	GET /user/:id/preferences - Lista géneros musicais favoritos do utilizador.
o	PUT /user/:id/preferences - Atualiza preferências musicais para recomendações personalizadas.

	Relações Sociais:
o	POST /user/:id/follow/:targetId - Seguir outro utilizador.
o	DELETE /user/:id/follow/:targetId - Deixar de seguir utilizador.
o	GET /user/:id/followers - Lista utilizadores que seguem o perfil.
o	GET /user/:id/following - Lista utilizadores que o perfil segue.

3.1.2	Publicações de Concertos

Este microsserviço permite que qualquer utilizador (artistas, promotores ou fãs) crie publicações sobre concertos e eventos. Foi desenvolvido com as seguintes características:

•	CRUD Completo de Publicações: Os utilizadores podem criar, ler, atualizar e eliminar publicações sobre concertos. Cada publicação contém informações como título, descrição, data, local, género musical e imagem.

•	Autenticação e Autorização: Integra-se com o serviço de autenticação para validar tokens JWT e garantir que apenas o criador da publicação pode editá-la ou eliminá-la.

•	Sistema de Filtragem e Pesquisa: Permite pesquisar publicações por título, género, localização ou data, facilitando a descoberta de eventos.

•	Gestão de Imagens: Suporta upload de imagens de capa para as publicações, armazenando referências na base de dados.

•	Feed Personalizado: Lista publicações ordenadas por data de criação, possibilitando a criação de feeds personalizados no frontend.

A base de dados publication_db armazena todas as publicações criadas pelos utilizadores, incluindo metadados e referências a imagens.

•	Endpoints API:
	Gestão de Publicações:
o	POST /publications - Cria nova publicação de concerto (requer autenticação).
o	GET /publications - Lista todas as publicações com paginação opcional.
o	GET /publications/:id - Obtém detalhes completos de uma publicação específica.
o	PUT /publications/:id - Atualiza publicação existente (apenas criador).
o	DELETE /publications/:id - Remove publicação (apenas criador ou admin).

	Pesquisa e Filtragem:
o	GET /publications/search - Pesquisa por título, artista ou descrição.
o	GET /publications/filter - Filtra por género, localização, data ou intervalo de preços.
o	GET /publications/user/:userId - Lista publicações de um utilizador específico.

	Interações:
o	POST /publications/:id/like - Marcar publicação como favorita.
o	DELETE /publications/:id/like - Remover dos favoritos.
o	GET /publications/:id/likes - Conta total de likes da publicação.

3.1.3	Eventos – Ticketmaster

O serviço de eventos é responsável por agregar informação de concertos provenientes de APIs externas, nomeadamente a Ticketmaster API:

•	Integração com Ticketmaster API: Realiza pedidos à API oficial da Ticketmaster para obter informação atualizada sobre concertos e eventos musicais em diferentes países.

•	Normalização de Dados: Processa e normaliza os dados recebidos, transformando-os num formato consistente utilizado internamente pela aplicação.

•	Sistema de Sincronização: Implementa endpoints que permitem sincronizar eventos de forma manual ou automática, com filtros por país, data e tamanho de resultados.

•	Cache e Armazenamento Local: Armazena eventos sincronizados na base de dados events_db para melhorar performance e reduzir chamadas à API externa.

•	Filtragem Avançada: Permite pesquisar eventos por artista, género musical, localização e intervalo de datas.

•	Geração Automática de Publicações: Quando novos eventos são sincronizados, pode automaticamente criar publicações no serviço de publicações, mantendo a plataforma atualizada.

Este serviço atua como ponte entre fontes externas de informação e o ecossistema interno da Backstage.

•	Endpoints API:
	Sincronização de Eventos:
o	GET /events/sync - Sincroniza eventos da Ticketmaster API (requer parâmetros de país/região).
o	POST /events/sync/schedule - Agenda sincronização automática periódica (admin).

	Consulta de Eventos:
o	GET /events - Lista todos os eventos disponíveis com paginação.
o	GET /events/:id - Detalhes completos de um evento específico.
o	GET /events/upcoming - Eventos futuros ordenados por data.
o	GET /events/past - Histórico de eventos já realizados.

	Pesquisa e Filtragem:
o	GET /events/search - Pesquisa por nome de artista, venue ou cidade.
o	GET /events/by-genre/:genre - Filtra eventos por género musical.
o	GET /events/by-location/:location - Eventos numa localização específica.
o	GET /events/by-date - Filtra por intervalo de datas (início e fim).
o	GET /events/by-artist/:artistId - Todos os eventos de um artista específico.

3.1.4	Marketplace

O marketplace fornece uma plataforma para utilizadores venderem e comprarem bilhetes de forma segura:

•	Sistema de Anúncios: Permite criar anúncios detalhados com título, descrição, preço, data do evento, localização e imagens dos bilhetes.

•	Gestão de Estado: Cada anúncio possui estados (disponível, vendido, expirado) que são automaticamente atualizados.

•	Filtros e Pesquisa: Os compradores podem pesquisar anúncios por evento, preço, localização ou data.

•	Verificação de Propriedade: Apenas o criador do anúncio pode editá-lo ou eliminá-lo, garantido através de middleware de autorização (isOwner).

•	Sistema de Contacto: Disponibiliza informações de contacto do vendedor (email, telefone) para facilitar a comunicação entre comprador e vendedor.

•	Integração com Autenticação: Valida a identidade dos utilizadores antes de permitir a criação ou modificação de anúncios.

Importante: A aplicação não processa transações financeiras, funcionando apenas como intermediário de informação.

•	Endpoints API:
	Gestão de Anúncios:
o	POST /market - Cria novo anúncio de venda de bilhete (requer autenticação).
o	GET /market - Lista todos os anúncios ativos com paginação.
o	GET /market/:id - Detalhes completos de um anúncio específico.
o	PUT /market/:id - Atualiza anúncio (apenas proprietário).
o	DELETE /market/:id - Remove anúncio (apenas proprietário).

	Pesquisa e Filtragem:
o	GET /market/search - Pesquisa por título de evento ou descrição.
o	GET /market/by-event/:eventId - Anúncios de um evento específico.
o	GET /market/by-price - Filtra por intervalo de preço (min/max).
o	GET /market/by-location/:location - Anúncios numa localização específica.
o	GET /market/user/:userId - Todos os anúncios de um vendedor.

	Gestão de Estado:
o	PATCH /market/:id/status - Atualiza estado do anúncio (disponível/vendido/expirado).
o	GET /market/active - Lista apenas anúncios disponíveis.
o	GET /market/sold - Histórico de bilhetes vendidos.

3.1.5	Passaporte

O Passaporte de Concertos é uma funcionalidade única que permite aos utilizadores documentarem a sua jornada musical:

•	Registo de Experiências: Os utilizadores podem criar posts sobre concertos a que assistiram, incluindo avaliações, comentários, fotos e a data em que compareceram.

•	Associação com Eventos: Cada entrada no passaporte está associada a um evento específico da base de dados, criando um histórico estruturado.

•	Geração de Estatísticas: O serviço calcula automaticamente estatísticas personalizadas:
o	Total de concertos assistidos
o	Artistas mais vistos
o	Géneros musicais predominantes
o	Locais mais frequentados
o	Distribuição temporal (concertos por mês/ano)

•	Dados Geográficos: Prepara informação de localização para integração com Google Maps API, permitindo visualizar num mapa todos os locais onde o utilizador já assistiu a concertos.

•	Timeline Pessoal: Organiza cronologicamente todas as experiências do utilizador, criando uma narrativa visual da sua jornada musical.

•	Privacidade e Partilha: Os utilizadores controlam a visibilidade das suas entradas (público/privado) e podem partilhar o seu passaporte com outros utilizadores.

•	Endpoints API:
	Gestão de Entradas:
o	POST /passport - Adiciona nova entrada de concerto ao passaporte (requer autenticação).
o	GET /passport/user/:userId - Lista todas as entradas do passaporte de um utilizador.
o	GET /passport/:id - Detalhes completos de uma entrada específica.
o	PUT /passport/:id - Atualiza entrada (avaliação, comentários, fotos).
o	DELETE /passport/:id - Remove entrada do passaporte.

	Estatísticas:
o	GET /passport/user/:userId/stats - Estatísticas gerais (total de concertos, artistas únicos, etc.).
o	GET /passport/user/:userId/top-artists - Artistas mais vistos pelo utilizador.
o	GET /passport/user/:userId/top-genres - Géneros musicais predominantes.
o	GET /passport/user/:userId/top-venues - Venues mais frequentados.
o	GET /passport/user/:userId/timeline - Distribuição temporal de concertos (por mês/ano).

	Mapa e Localização:
o	GET /passport/user/:userId/map-data - Dados geográficos para visualização em mapa.
o	GET /passport/user/:userId/locations - Lista de todas as localizações visitadas.

	Privacidade:
o	PATCH /passport/:id/visibility - Altera visibilidade (público/privado).
o	GET /passport/user/:userId/public - Apenas entradas públicas de um utilizador.

3.1.6	Notificações

O serviço de notificações garante que os utilizadores se mantêm informados sobre eventos relevantes:

•	Sistema de Notificações em Tempo Real: Utiliza Redis como cache para armazenar notificações de forma eficiente e garantir acesso rápido.

•	Tipos de Notificações:
o	Novos concertos de artistas/géneros favoritos
o	Atualizações de eventos que o utilizador marcou como interessado
o	Alertas de novos anúncios no marketplace
o	Notificações sociais (novos seguidores, comentários)
o	Recomendações personalizadas baseadas nas preferências

•	Gestão de Estado: As notificações podem ser marcadas como lidas/não lidas e organizadas por prioridade.

•	Event Handlers com RabbitMQ: Subscreve eventos de outros microsserviços através de RabbitMQ:
o	UserEventHandler: Reage a eventos de novos utilizadores
o	ConcertRecommendationHandler: Processa recomendações de concertos baseadas nas preferências do utilizador

•	Preferências de Notificação: Os utilizadores podem configurar que tipos de notificações desejam receber e através de que canais.

•	Sistema de Contadores: Mantém contagem de notificações não lidas para exibir badges no frontend.

•	Integração com Push Notifications: Preparado para integração com serviços de push notifications (Firebase Cloud Messaging, OneSignal) para enviar alertas aos dispositivos móveis.

A arquitetura baseada em eventos permite que o serviço de notificações reaja automaticamente a ações em outros microsserviços, mantendo os utilizadores sempre informados.

•	Endpoints API:
	Gestão de Notificações:
o	GET /notifications/:userId - Lista todas as notificações de um utilizador.
o	GET /notifications/:userId/unread - Apenas notificações não lidas.
o	GET /notifications/:notificationId - Detalhes de uma notificação específica.
o	PATCH /notifications/:notificationId/read - Marca notificação como lida.
o	PATCH /notifications/:userId/read-all - Marca todas como lidas.
o	DELETE /notifications/:notificationId - Remove notificação.
o	DELETE /notifications/:userId/clear - Limpa todas as notificações.

	Preferências:
o	GET /notifications/:userId/preferences - Obtém configurações de notificação.
o	PUT /notifications/:userId/preferences - Atualiza tipos de notificações a receber.
o	PATCH /notifications/:userId/preferences/toggle - Liga/desliga notificações.

	Contadores e Resumo:
o	GET /notifications/:userId/count - Total de notificações não lidas.
o	GET /notifications/:userId/summary - Resumo por tipo de notificação.


3.2	 Segurança entre Microsserviços

A segurança é um aspecto fundamental da arquitetura da Backstage, implementada em múltiplas camadas para garantir a proteção dos dados dos utilizadores e a integridade do sistema:

•	Autenticação baseada em JWT (JSON Web Tokens):
o	Todos os pedidos autenticados utilizam tokens JWT assinados com chaves secretas (ACCESS_TOKEN_SECRET e REFRESH_TOKEN_SECRET).
o	Os tokens contêm informação do utilizador (ID, email, role) e têm tempo de expiração definido.
o	Implementação de um sistema dual com access tokens de curta duração e refresh tokens de longa duração, minimizando o risco de roubo de credenciais.

•	Middleware de Autenticação Partilhado:
o	Cada microsserviço implementa o middleware authenticateToken que valida os tokens JWT recebidos nos headers das requisições.
o	Pedidos sem token válido são imediatamente rejeitados com status 401 (Unauthorized) ou 403 (Forbidden).

•	Controlo de Acesso Baseado em Roles (RBAC):
o	Sistema de roles que distingue entre utilizadores comuns (user) e administradores (admin).
o	Middleware roleMiddleware garante que apenas utilizadores com permissões adequadas podem aceder a determinados endpoints (ex: criar eventos oficiais, eliminar publicações de outros utilizadores).

•	Verificação de Propriedade de Recursos:
o	Middleware isOwner valida que o utilizador que tenta modificar/eliminar um recurso é o seu proprietário legítimo.
o	Implementado em serviços como marketplace, publicações e passaporte.

•	Encriptação de Passwords:
o	Todas as passwords são encriptadas usando bcrypt com salt rounds antes de serem armazenadas na base de dados.
o	As passwords nunca são armazenadas em texto simples nem retornadas nas respostas da API.

•	Variáveis de Ambiente e Secrets:
o	Informações sensíveis (segredos JWT, credenciais de base de dados, API keys) são armazenadas em variáveis de ambiente (.env) e nunca commitadas no repositório.
o	Em produção, utilização de sistemas de gestão de secrets do Kubernetes.

•	Validação de Input:
o	Validação rigorosa de todos os dados recebidos para prevenir ataques de SQL injection e XSS.
o	Sanitização de inputs antes de processamento.

•	CORS (Cross-Origin Resource Sharing):
o	Configuração adequada de CORS no API Gateway para controlar que domínios podem aceder à API.
o	Em produção, restrição a domínios específicos (variável ALLOWED_ORIGINS).

•	Rate Limiting (planejado):
o	Implementação de limitação de taxa de pedidos para prevenir ataques DDoS e abuso da API.

•	HTTPS/TLS:
o	Em produção, todas as comunicações são encriptadas através de HTTPS/TLS.
o	Certificados SSL geridos automaticamente através de Let's Encrypt ou serviços cloud.


3.3	 Comunicação entre Microsserviços

A Backstage implementa dois padrões distintos de comunicação entre microsserviços, cada um adequado a diferentes cenários:

3.3.1	Comunicação Síncrona (HTTP/REST)

A comunicação síncrona é utilizada quando um microsserviço necessita de uma resposta imediata de outro serviço:

•	API Gateway como Ponto Central:
o	O NGINX/Express Gateway atua como único ponto de entrada para o sistema.
o	Roteia pedidos HTTP para os microsserviços apropriados baseado no path:
	/auth/* → Serviço de Autenticação (porta 4000)
	/publications/* → Serviço de Publicações (porta 3000)
	/events/* → Serviço de Eventos (porta 7000)
	/market/* → Marketplace (porta 6000)
	/passport/* → Passaporte (porta 5000)
	/notifications/* → Notificações (porta 8000)

•	Proxy Reverso com express-http-proxy:
o	O gateway utiliza a biblioteca express-http-proxy para encaminhar pedidos mantendo headers, cookies e corpo das requisições.
o	Configuração de timeouts e gestão de erros para garantir resiliência.

•	Service Discovery:
o	Em ambiente Docker/Kubernetes, os serviços comunicam através de nomes de serviço (DNS interno) em vez de IPs fixos.
o	Exemplo: auth-database, publication-database, rabbitmq são resolvidos automaticamente.

•	Health Checks:
o	Cada microsserviço expõe um endpoint /health que retorna o estado do serviço.
o	O orquestrador (Docker Compose/Kubernetes) monitoriza estes endpoints para garantir disponibilidade.

•	Chamadas Inter-Serviços (quando necessário):
o	Alguns microsserviços fazem pedidos HTTP diretos a outros quando necessitam de dados complementares.
o	Exemplo: O serviço de publicações pode consultar o serviço de autenticação para validar tokens.

3.3.2	Comunicação Assíncrona (Event-Driven com RabbitMQ)

Para operações que não requerem resposta imediata ou que devem notificar múltiplos serviços, implementou-se comunicação assíncrona baseada em eventos:

•	RabbitMQ como Message Broker:
o	Sistema de mensagens que implementa o padrão publish-subscribe.
o	Garante entrega fiável de mensagens mesmo se o serviço destinatário estiver temporariamente indisponível.
o	Interface de gestão disponível na porta 15672 para monitorização de filas e exchanges.

•	Padrão Event-Driven:
o	Quando ocorrem eventos importantes, os microsserviços publicam mensagens em exchanges do RabbitMQ.
o	Outros serviços que subscrevem esses eventos recebem e processam as mensagens de forma independente.

•	Casos de Uso Implementados:

1.	Criação de Novo Utilizador:
o	O serviço de autenticação publica evento "user.created" quando um utilizador se regista.
o	O serviço de notificações subscreve este evento e envia email de boas-vindas.
o	Futuras extensões podem subscrever o mesmo evento (ex: serviço de analytics, CRM).

2.	Recomendações de Concertos:
o	O serviço de eventos publica evento "concert.recommendation" quando deteta novos concertos que correspondem às preferências de utilizadores.
o	O serviço de notificações consome estes eventos e cria notificações personalizadas para os utilizadores afetados.

3.	Atualizações de Estado:
o	Quando um bilhete no marketplace é marcado como vendido, pode publicar evento para atualizar estatísticas ou notificar utilizadores interessados.

•	Vantagens da Comunicação Assíncrona:
o	Desacoplamento: Serviços não precisam conhecer detalhes uns dos outros.
o	Resiliência: Mensagens são persistidas e reenviadas em caso de falha.
o	Escalabilidade: Múltiplos consumidores podem processar mensagens em paralelo.
o	Extensibilidade: Novos serviços podem facilmente subscrever eventos existentes.

•	Implementação Técnica:
o	Cada microsserviço que utiliza RabbitMQ tem um módulo utils/rabbitmq.js que gere a conexão.
o	Função connectRabbitMQ() estabelece conexão e cria canal de comunicação.
o	Event handlers específicos (UserEventHandler, ConcertRecommendationHandler) processam tipos específicos de eventos.

•	Garantias de Entrega:
o	Configuração de acknowledgments para garantir que mensagens só são removidas da fila após processamento bem-sucedido.
o	Dead Letter Queues (DLQ) para mensagens que falharam repetidamente.


3.4	 Publicação em Cloud

3.4.1	Containerização e Kubernetes

A aplicação Backstage foi desenvolvida seguindo princípios cloud-native, com containerização completa e preparação para deployment em Kubernetes:

•	Containerização com Docker:
o	Cada microsserviço possui um Dockerfile otimizado que define o ambiente de execução.
o	Imagens baseadas em node:18-alpine para minimizar tamanho e vulnerabilidades.
o	Multi-stage builds (quando aplicável) para separar dependências de desenvolvimento e produção.
o	Cada container expõe apenas a porta necessária e opera com privilégios mínimos.

•	Docker Compose para Desenvolvimento:
o	Ficheiro docker-compose.yaml define toda a stack de desenvolvimento:
	6 microsserviços (auth, publications, events, market, passport, notifications)
	1 API Gateway
	5 bases de dados PostgreSQL independentes (uma por microsserviço)
	1 instância RabbitMQ com interface de gestão
o	Redes isoladas para comunicação entre containers.
o	Volumes persistentes para dados das bases de dados e RabbitMQ.
o	Health checks configurados para garantir inicialização ordenada (depends_on com conditions).
o	Variáveis de ambiente centralizadas em ficheiro .env.

•	Preparação para Kubernetes:
o	Todos os serviços são stateless, com estado armazenado em bases de dados ou caches externos.
o	Configuração externalizada através de ConfigMaps e Secrets.
o	Probes de liveness e readiness implementados (/health endpoints).
o	Arquitetura preparada para horizontal pod autoscaling.

•	DigitalOcean Kubernetes (DOKS):
o	Cluster Kubernetes gerido para deployment em produção.
o	Managed PostgreSQL para bases de dados com backups automáticos.
o	Load Balancer gerido para distribuir tráfego.
o	Volumes persistentes para dados que precisam sobreviver a restarts de pods.

•	Manifests Kubernetes (planejados):
o	Deployments para cada microsserviço com estratégias de rolling updates.
o	Services para expor microsserviços internamente (ClusterIP) e gateway externamente (LoadBalancer).
o	ConfigMaps para variáveis de ambiente não sensíveis.
o	Secrets para credenciais, tokens JWT e API keys.
o	Ingress para gestão de tráfego HTTP/HTTPS e SSL/TLS termination.
o	HorizontalPodAutoscaler para escalar pods baseado em CPU/memória.

•	Registry de Imagens:
o	Docker images publicadas em registry (Docker Hub ou DigitalOcean Container Registry).
o	Tagging semântico (v1.0.0, v1.1.0, latest).
o	Scanning automático de vulnerabilidades nas imagens.

3.4.2	Escalabilidade

A arquitetura foi concebida para escalar horizontal e verticalmente:

•	Escalabilidade Horizontal (Horizontal Scaling):
o	Microsserviços stateless podem ter múltiplas réplicas executando simultaneamente.
o	Load balancer distribui tráfego entre réplicas utilizando algoritmos como round-robin.
o	Kubernetes Horizontal Pod Autoscaler (HPA) aumenta/diminui número de pods baseado em métricas:
	CPU utilization > 70% → adiciona pods
	Memória utilization > 80% → adiciona pods
	Número de pedidos por segundo → adiciona pods
o	Cada microsserviço pode escalar independentemente baseado na sua carga específica.

•	Escalabilidade da Base de Dados:
o	PostgreSQL com read replicas para distribuir queries de leitura.
o	Connection pooling para gerir eficientemente conexões à base de dados.
o	Índices otimizados em colunas frequentemente pesquisadas.
o	Caching com Redis para reduzir carga na base de dados (implementado no serviço de notificações).

•	Message Queue (RabbitMQ):
o	Múltiplos consumidores podem processar mensagens da mesma fila em paralelo.
o	Clustering de RabbitMQ para alta disponibilidade.
o	Particionamento de filas para distribuir carga.

•	Caching Strategy:
o	Redis para cache de dados frequentemente acedidos (notificações, sessões).
o	Cache no nível do API Gateway para respostas estáticas ou semi-estáticas.
o	CDN (Content Delivery Network) para servir assets estáticos (imagens, CSS, JS).

•	Rate Limiting e Throttling:
o	Proteção contra picos de tráfego através de rate limiting no API Gateway.
o	Backpressure mechanisms para prevenir sobrecarga dos serviços.

•	Monitorização e Métricas:
o	Prometheus para coletar métricas de performance (CPU, memória, latência, throughput).
o	Grafana para visualização de dashboards.
o	Alerting quando métricas ultrapassam thresholds definidos.

•	Otimizações de Performance:
o	Compressão de respostas HTTP (gzip/brotli) no API Gateway.
o	Paginação em endpoints que retornam listas de dados.
o	Lazy loading de dados no frontend.
o	Database query optimization e uso apropriado de índices.


3.5	 Instalação e Configuração

Esta secção descreve os passos necessários para configurar e executar a aplicação Backstage em ambiente de desenvolvimento ou produção.

Pré-requisitos:

•	Node.js (versão 18 ou superior)
•	Docker e Docker Compose
•	PostgreSQL (se executar sem Docker)
•	Git

Instalação Local (Desenvolvimento):

1.	Clonar o Repositório:
git clone https://github.com/Alexmarques11/Backstage.git
cd Backstage/backend

2.	Configurar Variáveis de Ambiente:
Criar ficheiro .env na raiz do projeto backend:

# Database
DATABASE_USER=user123
DATABASE_PASSWORD=123456
DATABASE_SSL=false

# JWT Secrets
ACCESS_TOKEN_SECRET=your_super_secret_access_token_key_change_in_production
REFRESH_TOKEN_SECRET=your_super_secret_refresh_token_key_change_in_production

# RabbitMQ
RABBITMQ_USER=backstage
RABBITMQ_PASSWORD=rabbitmq123
RABBITMQ_URL=amqp://backstage:rabbitmq123@rabbitmq:5672

# External APIs
TICKETMASTER_API_KEY=your_ticketmaster_api_key

# Environment
NODE_ENV=development
ALLOWED_ORIGINS=*

3.	Executar com Docker Compose:
docker-compose up -d

Este comando irá:
- Criar e iniciar todos os containers (microsserviços, bases de dados, RabbitMQ)
- Criar redes Docker para comunicação entre serviços
- Criar volumes para persistência de dados
- Executar health checks para garantir que serviços estão operacionais

4.	Verificar Estado dos Serviços:
docker-compose ps

Todos os serviços devem mostrar estado "Up" e "healthy".

5.	Aceder aos Serviços:
- API Gateway: http://localhost:8000
- RabbitMQ Management: http://localhost:15672 (user: backstage, pass: rabbitmq123)
- Swagger Documentation: http://localhost:8000/auth/api-docs

6.	Inicializar Bases de Dados:
As tabelas são criadas automaticamente quando cada microsserviço inicia pela primeira vez.

7.	Testar Endpoints:
Utilizar ficheiros .rest em cada pasta de microsserviço ou ferramentas como Postman/Insomnia.

Instalação em Produção (Kubernetes):

1.	Preparar Cluster Kubernetes:
- Criar cluster no DigitalOcean Kubernetes (DOKS)
- Configurar kubectl para conectar ao cluster

2.	Criar Secrets:
kubectl create secret generic backstage-secrets \
  --from-literal=database-user=user123 \
  --from-literal=database-password=secure_password_here \
  --from-literal=jwt-access-secret=production_access_secret \
  --from-literal=jwt-refresh-secret=production_refresh_secret

3.	Aplicar Manifests Kubernetes:
kubectl apply -f k8s/

4.	Configurar Ingress e SSL:
- Instalar NGINX Ingress Controller
- Configurar cert-manager para certificados Let's Encrypt

5.	Monitorização:
- Instalar Prometheus e Grafana
- Configurar dashboards e alertas

6.	Backups:
- Configurar backups automáticos das bases de dados
- Testar procedimentos de restore

Comandos Úteis:

# Ver logs de um serviço
docker-compose logs -f [service_name]

# Restart de um serviço específico
docker-compose restart [service_name]

# Parar todos os serviços
docker-compose down

# Parar e remover volumes (ATENÇÃO: apaga dados)
docker-compose down -v

# Rebuild de imagens após alterações
docker-compose up -d --build

# Executar comandos dentro de um container
docker-compose exec [service_name] sh

# Ver estado dos pods em Kubernetes
kubectl get pods

# Ver logs de um pod
kubectl logs -f [pod_name]

# Aplicar alterações de configuração
kubectl apply -f [manifest_file]

Resolução de Problemas Comuns:

1.	Erro de conexão à base de dados:
- Verificar se o container da base de dados está running e healthy
- Confirmar variáveis de ambiente corretas
- Verificar logs: docker-compose logs [database_service]

2.	Erro 401/403 em pedidos autenticados:
- Verificar se ACCESS_TOKEN_SECRET é igual em todos os serviços
- Confirmar formato do token no header: "Authorization: Bearer [token]"
- Verificar se token não expirou

3.	RabbitMQ connection failed:
- Confirmar que RabbitMQ está running: docker-compose ps rabbitmq
- Verificar RABBITMQ_URL nas variáveis de ambiente
- Verificar logs: docker-compose logs rabbitmq
 
 
4.	Conclusão

4.1	 Objetivos Atingidos

O projeto Backstage alcançou com sucesso os principais objetivos estabelecidos, criando uma plataforma completa e moderna para entusiastas de música, artistas e promotores de eventos:

•	Arquitetura de Microsserviços Completa:
o	Implementação de 6 microsserviços independentes (Autenticação, Publicações, Eventos, Marketplace, Passaporte e Notificações), cada um com responsabilidades bem definidas.
o	Cada serviço opera de forma autónoma com a sua própria base de dados PostgreSQL, garantindo isolamento e escalabilidade.

•	Sistema de Autenticação Robusto:
o	Implementação de autenticação baseada em JWT com sistema dual de tokens (access e refresh).
o	Controlo de acesso baseado em roles (RBAC) e verificação de propriedade de recursos.
o	Encriptação segura de passwords com bcrypt.

•	Hub Centralizado de Informação:
o	Integração bem-sucedida com a Ticketmaster API para obter informação atualizada sobre concertos.
o	Sistema de publicações que permite a qualquer utilizador divulgar eventos.
o	Filtragem e pesquisa avançada por artista, género, localização e data.

•	Marketplace Funcional:
o	Plataforma completa para criação e gestão de anúncios de revenda de bilhetes.
o	Sistema de estados e validações que garante integridade dos anúncios.
o	Pesquisa e filtragem eficiente para facilitar encontro entre compradores e vendedores.

•	Passaporte de Concertos Inovador:
o	Funcionalidade única que permite aos utilizadores documentar as suas experiências musicais.
o	Geração automática de estatísticas personalizadas (artistas mais vistos, géneros favoritos, locais frequentados).
o	Preparação para visualização geográfica através de integração com Google Maps API.

•	Sistema de Notificações em Tempo Real:
o	Implementação de notificações baseadas em eventos com RabbitMQ.
o	Cache eficiente com Redis para acesso rápido a notificações.
o	Recomendações personalizadas baseadas nas preferências musicais dos utilizadores.

•	Comunicação Entre Microsserviços:
o	Implementação dual de comunicação síncrona (HTTP/REST) e assíncrona (event-driven com RabbitMQ).
o	API Gateway centralizado que roteia pedidos de forma eficiente.
o	Event handlers que reagem a eventos de outros serviços, promovendo desacoplamento.

•	Containerização e Preparação para Cloud:
o	Todos os serviços containerizados com Docker.
o	Docker Compose funcional para ambiente de desenvolvimento.
o	Arquitetura preparada para deployment em Kubernetes (DigitalOcean).
o	Health checks e service discovery implementados.

•	Documentação e Testes:
o	Swagger/OpenAPI documentation para todos os endpoints de autenticação.
o	Ficheiros .rest para facilitar testes de API.
o	Estrutura preparada para implementação de testes unitários e de integração.


4.2	 Problemas Encontrados

Durante o desenvolvimento do projeto, foram identificados e enfrentados diversos desafios técnicos:

•	Complexidade da Arquitetura de Microsserviços:
o	Gestão de múltiplas bases de dados e garantia de consistência de dados entre serviços.
o	Debugging distribuído - rastrear erros através de múltiplos serviços revelou-se mais complexo que em aplicações monolíticas.
o	Necessidade de implementar correlation IDs para rastreamento de pedidos através dos serviços.

•	Comunicação Entre Serviços:
o	Configuração inicial do RabbitMQ e estabelecimento de padrões de mensagens consistentes.
o	Gestão de timeouts e retry logic em comunicações síncronas.
o	Necessidade de implementar circuit breakers para prevenir falhas em cascata.

•	Sincronização com APIs Externas:
o	Rate limiting da Ticketmaster API exigiu implementação de cache e throttling.
o	Normalização de dados de diferentes formatos e estruturas.
o	Gestão de falhas quando APIs externas estão indisponíveis.

•	Gestão de Segurança:
o	Garantir que todos os microsserviços validam tokens JWT de forma consistente.
o	Gestão segura de secrets em diferentes ambientes (desenvolvimento, produção).
o	Implementação de CORS adequada sem comprometer segurança.

•	Performance e Otimização:
o	Queries N+1 em relações de base de dados exigiram otimização.
o	Necessidade de implementar paginação em endpoints que retornam grandes volumes de dados.
o	Balanceamento entre consistência e performance em operações distribuídas.

•	Gestão de Estado e Cache:
o	Implementação de cache eficiente para notificações com Redis.
o	Invalidação de cache quando dados são atualizados em outros serviços.
o	Sincronização de estado entre múltiplas instâncias do mesmo serviço.

•	Deployment e DevOps:
o	Configuração de health checks apropriados para cada serviço.
o	Ordem de inicialização de serviços (dependências entre bases de dados e aplicações).
o	Gestão de volumes e persistência de dados em Docker.

•	Integração Frontend-Backend:
o	Definição de contratos de API claros entre equipas frontend e backend.
o	Gestão de CORS e autenticação entre domínios diferentes.
o	Versionamento de APIs para garantir compatibilidade.


4.3	 Melhorias Futuras

Embora o projeto tenha alcançado os objetivos principais, existem várias áreas identificadas para desenvolvimento futuro:

•	Funcionalidades da Aplicação:

o	Sistema de Comentários e Reviews: Permitir aos utilizadores comentar em publicações e eventos, criar reviews de concertos.
o	Sistema de Favoritos: Marcar eventos e publicações como favoritos para acesso rápido.
o	Feed Social Avançado: Timeline personalizada baseada em utilizadores seguidos e preferências.
o	Chat em Tempo Real: Integração de messaging para comunicação direta entre compradores e vendedores no marketplace.
o	Sistema de Verificação: Badge de verificação para artistas oficiais e vendedores confiáveis.
o	Gamificação: Badges e achievements baseados no número de concertos assistidos, variedade de géneros, etc.
o	Recomendações com Machine Learning: Algoritmos mais sofisticados para recomendar concertos baseados em comportamento do utilizador.

•	Melhorias Técnicas:

o	Implementação Completa de CI/CD:
	Pipeline automático com GitHub Actions
	Testes automáticos (unit, integration, e2e)
	Deployment automático para staging e produção
	Rollback automático em caso de falhas

o	Observabilidade e Monitorização:
	Implementação de distributed tracing (Jaeger, Zipkin)
	Logging centralizado (ELK Stack ou Grafana Loki)
	Dashboards de métricas de negócio e técnicas (Grafana)
	Alerting proativo baseado em anomalias

o	Resiliência e Reliability:
	Circuit breakers com bibliotecas como Hystrix ou resilience4j
	Retry policies com exponential backoff
	Bulkhead pattern para isolamento de recursos
	Chaos engineering para testar resiliência

o	Performance:
	Implementação de CDN para assets estáticos
	Server-side caching strategies
	Database read replicas para distribuir carga
	Query optimization e índices adicionais
	GraphQL para reduzir over-fetching de dados

o	Segurança:
	Implementação de OAuth2 / OpenID Connect
	Two-factor authentication (2FA)
	Security scanning automático (SAST, DAST)
	Penetration testing regular
	Web Application Firewall (WAF)
	DDoS protection

•	Escalabilidade e Cloud:

o	Deployment completo em Kubernetes:
	Manifests completos (Deployments, Services, Ingress, ConfigMaps, Secrets)
	Horizontal Pod Autoscaling configurado
	Vertical Pod Autoscaling para otimização de recursos
	Service Mesh (Istio) para gestão avançada de tráfego

o	Multi-region deployment para reduzir latência global
o	Database sharding para escalar horizontalmente
o	Event sourcing e CQRS para operações críticas
o	Message queue clustering para alta disponibilidade

•	Experiência do Utilizador:

o	Aplicação Mobile Nativa: Desenvolvimento completo da app Android/iOS em Kotlin/Swift
o	Progressive Web App (PWA): Versão web que funciona offline
o	Notificações Push: Integração com Firebase Cloud Messaging
o	Deep Linking: Links diretos para conteúdo específico na app
o	Personalização de UI: Temas, dark mode, preferências de visualização
o	Acessibilidade: Conformidade com WCAG guidelines

•	Funcionalidades de Negócio:

o	Sistema de Pagamentos: Integração com Stripe/PayPal para processamento seguro de transações
o	Sistema de Comissões: Plataforma recebe percentagem em vendas do marketplace
o	Planos Premium: Funcionalidades exclusivas para utilizadores pagantes
o	Analytics Dashboard: Para artistas e promotores verem estatísticas de engagement
o	API Pública: Permitir terceiros integrarem com a plataforma
o	Partnerships: Integração com outras plataformas de venda de bilhetes

•	Data e Analytics:

o	Data Lake para armazenar dados históricos
o	Business Intelligence dashboards
o	Predictive analytics para prever tendências
o	A/B testing framework para otimizar features
o	User behavior tracking e funnel analysis

•	Compliance e Legal:

o	GDPR compliance completo
o	Política de privacidade e termos de serviço
o	Sistema de consentimento de cookies
o	Data retention e deletion policies
o	Audit logs para compliance

Conclusão Final:

O projeto Backstage representa uma implementação bem-sucedida de uma arquitetura moderna de microsserviços cloud-native, demonstrando competências em desenvolvimento backend, containerização, comunicação distribuída e design de sistemas escaláveis. A plataforma criada oferece valor real aos entusiastas de música, artistas e promotores, solucionando problemas identificados no mercado atual.

Embora existam melhorias e funcionalidades adicionais planeadas, a base sólida estabelecida permite evolução contínua e adaptação a necessidades futuras. A experiência adquirida durante o desenvolvimento, especialmente na resolução de desafios relacionados com sistemas distribuídos, segurança e performance, constitui um valioso aprendizado aplicável a projetos futuros de larga escala.

A Backstage está preparada para crescer, escalar e continuar a enriquecer a experiência musical dos seus utilizadores, promovendo descoberta, partilha e conexão através da música ao vivo.